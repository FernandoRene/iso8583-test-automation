package com.iso8583.test.steps;

import com.iso8583.test.client.ISO8583ApiClient;
import com.iso8583.test.config.TestConfig;
import com.iso8583.test.utils.ValidationHelper;
import io.cucumber.java.es.*;
import io.cucumber.datatable.DataTable;
import io.qameta.allure.Allure;
import io.qameta.allure.Step;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.*;

/**
 * Step Definitions para Balance Inquiry E2E Tests
 * Implementa los pasos del feature file balance_inquiry.feature
 */
public class BalanceInquirySteps {

    private static final Logger logger = LoggerFactory.getLogger(BalanceInquirySteps.class);

    // Shared state entre steps
    private ISO8583ApiClient apiClient;
    private Response lastResponse;
    private String currentPan;
    private String currentTrack2;
    private String currentTerminalId;
    private String currentCardAcceptorId;
    private String currentAccount;
    private List<Response> multipleResponses = new ArrayList<>();
    private long startTime;

    // ============================================================================
    // BACKGROUND STEPS
    // ============================================================================

    @Dado("que el simulador ISO8583 est√° disponible en {string}")
    public void simuladorDisponible(String baseUrl) {
        logger.info("üîß Inicializando cliente API con baseUrl: {}", baseUrl);
        // Habilitar logging de RestAssured
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();

        // Usar configuraci√≥n si no se especifica URL
        if (baseUrl == null || baseUrl.isEmpty()) {
            baseUrl = TestConfig.getBaseUrl();
        }

        apiClient = new ISO8583ApiClient(baseUrl);

        // Verificar que el servicio est√° disponible usando /ready
        Response readyCheck = apiClient.isServiceReady();
        int statusCode = readyCheck.statusCode();

        Allure.addAttachment("Base URL", baseUrl);
        Allure.addAttachment("Ready Check Status Code", String.valueOf(statusCode));

        if (statusCode == 200) {
            // ‚úÖ Servicio LISTO
            boolean ready = readyCheck.jsonPath().getBoolean("ready");
            assertThat(ready)
                    .as("Servicio debe estar listo cuando retorna 200 OK")
                    .isTrue();

            logger.info("‚úÖ Simulador disponible y LISTO para procesar transacciones");
            Allure.addAttachment("Service Status", "READY");

        } else if (statusCode == 503) {
            // ‚ö†Ô∏è Servicio NO LISTO pero funcionando
            logger.warn("‚ö†Ô∏è Simulador disponible pero NO LISTO (HTTP 503)");
            String message = readyCheck.jsonPath().getString("message");
            String reason = readyCheck.jsonPath().getString("details.reason");

            Allure.addAttachment("Service Status", "NOT READY");
            Allure.addAttachment("Reason", reason != null ? reason : "Unknown");

            fail("Simulador no est√° listo para procesar transacciones.\n" +
                    "Raz√≥n: " + (reason != null ? reason : message) + "\n" +
                    "Acci√≥n: Verificar conexi√≥n con el autorizador");

        } else {
            // ‚ùå Error inesperado
            logger.error("‚ùå Simulador no disponible - HTTP {}", statusCode);
            fail("Simulador no disponible. HTTP Status: " + statusCode);
        }
    }

    @Y("el servicio est√° en modo {string} conectado al autorizador")
    @Step("Verificar que el servicio est√° en modo {mode}")
    public void servicioEnModo(String mode) {
        logger.info("üîß Verificando modo del servicio: {}", mode);

        Response statusResponse = apiClient.getConnectionStatus();
        assertThat(statusResponse.statusCode()).isEqualTo(200);

        // Capturar informaci√≥n del modo actual (si est√° disponible en la respuesta)
        try {
            String actualMode = statusResponse.jsonPath().getString("mode");
            if (actualMode != null) {
                Allure.addAttachment("Modo Actual", actualMode);
                logger.info("üìä Modo actual del simulador: {}", actualMode);
            }
        } catch (Exception e) {
            // El modo puede no estar en la respuesta, ignorar
            logger.debug("Modo no disponible en respuesta de status");
        }

        // Agregar informaci√≥n adicional como attachment
        Allure.addAttachment("Connection Status", "application/json",
                statusResponse.getBody().prettyPrint());

        logger.info("‚úÖ Servicio configurado en modo: {}", mode);
    }

    @Y("la conexi√≥n con el autorizador est√° establecida")
    public void conexionEstablecida() {
        logger.info("üîå Verificando conexi√≥n con autorizador...");

        Response connectionStatus = apiClient.getConnectionStatus();
        assertThat(connectionStatus.statusCode()).isEqualTo(200);

        boolean isConnected = connectionStatus.jsonPath().getBoolean("connected");

        if (!isConnected) {
            logger.info("‚ö†Ô∏è No hay conexi√≥n, intentando conectar...");
            Response connectResponse = apiClient.connect();
            assertThat(connectResponse.statusCode()).isEqualTo(200);

            // Esperar un poco para que se establezca
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        logger.info("‚úÖ Conexi√≥n con autorizador establecida");
        Allure.addAttachment("Estado Conexi√≥n", "CONECTADO");
    }

    // ============================================================================
    // GIVEN STEPS
    // ============================================================================

    @Dado("que tengo una tarjeta con PAN {string}")
    @Step("Configurar tarjeta con PAN {pan}")
    public void tarjetaConPan(String pan) {
        logger.info("üí≥ Configurando PAN: {}...{}",
                pan.substring(0, 6), pan.substring(pan.length()-4));

        this.currentPan = pan;
        Allure.addAttachment("PAN (Masked)", maskPan(pan));
    }

    @Y("el Track2 es {string}")
    @Step("Configurar Track2")
    public void track2Es(String track2) {
        logger.info("üí≥ Configurando Track2");
        this.currentTrack2 = track2;
        Allure.addAttachment("Track2 (Masked)", maskTrack2(track2));
    }

    @Y("la terminal {string} est√° configurada")
    @Step("Configurar Terminal ID: {terminalId}")
    public void terminalConfigurada(String terminalId) {
        logger.info("üèß Configurando Terminal: {}", terminalId);
        this.currentTerminalId = terminalId;
        Allure.addAttachment("Terminal ID", terminalId);
    }

    @Y("el comercio {string} est√° activo")
    @Step("Configurar Card Acceptor: {cardAcceptorId}")
    public void comercioActivo(String cardAcceptorId) {
        logger.info("üè™ Configurando Card Acceptor: {}", cardAcceptorId);
        this.currentCardAcceptorId = cardAcceptorId;
        Allure.addAttachment("Card Acceptor ID", cardAcceptorId);
    }

    @Y("la cuenta a consultar es {string}")
    @Step("Configurar cuenta: {account}")
    public void cuentaConsultar(String account) {
        logger.info("üí∞ Configurando cuenta: {}", account);
        this.currentAccount = account;
        Allure.addAttachment("Account", account);
    }

    @Y("se pierde la conexi√≥n con el autorizador")
    public void perdidaConexion() {
        logger.info("üîå Simulando p√©rdida de conexi√≥n...");
        apiClient.disconnect();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        logger.info("‚ùå Conexi√≥n perdida");
    }

    @Y("el autorizador est√° configurado para no responder")
    public void autorizadorNoResponde() {
        logger.info("‚ö†Ô∏è Configurando escenario de timeout...");
        // Este es un paso de preparaci√≥n, el timeout se manejar√° naturalmente
        Allure.step("Autorizador configurado para timeout");
    }

    // ============================================================================
    // WHEN STEPS
    // ============================================================================

    @Cuando("env√≠o una solicitud de consulta de saldo")
    public void envioConsultaSaldo() {
        logger.info("üì§ Enviando Balance Inquiry...");

        // LOG PAR√ÅMETROS ANTES DE ENVIAR
        logRequestParameters();
        startTime = System.currentTimeMillis();

        lastResponse = apiClient.sendBalanceInquiry(
                currentPan,
                currentTrack2,
                currentTerminalId,
                currentCardAcceptorId,
                currentAccount
        );

        long responseTime = System.currentTimeMillis() - startTime;
        logger.info("üì• Respuesta recibida en {}ms", responseTime);

        Allure.addAttachment("Response Time", responseTime + "ms");
        Allure.addAttachment("HTTP Status", String.valueOf(lastResponse.statusCode()));
        Allure.addAttachment("Response Body", lastResponse.getBody().prettyPrint());
    }

    @Cuando("env√≠o {int} solicitudes de consulta de saldo consecutivas")
    public void envioMultiplesConsultas(int cantidad) {
        logger.info("üì§ Enviando {} consultas consecutivas...", cantidad);

        multipleResponses.clear();
        startTime = System.currentTimeMillis();

        for (int i = 0; i < cantidad; i++) {
            Response response = apiClient.sendBalanceInquiry(
                    currentPan,
                    currentTrack2,
                    currentTerminalId,
                    currentCardAcceptorId,
                    currentAccount
            );
            multipleResponses.add(response);

            logger.info("‚úÖ Consulta {}/{} completada", i+1, cantidad);
        }

        long totalTime = System.currentTimeMillis() - startTime;
        logger.info("üì• {} consultas completadas en {}ms", cantidad, totalTime);

        Allure.addAttachment("Cantidad de Consultas", String.valueOf(cantidad));
        Allure.addAttachment("Tiempo Total", totalTime + "ms");
    }

    @Cuando("se restablece la conexi√≥n autom√°ticamente")
    public void restablecerConexion() {
        logger.info("üîÑ Restableciendo conexi√≥n...");

        Response connectResponse = apiClient.connect();
        assertThat(connectResponse.statusCode()).isEqualTo(200);

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        logger.info("‚úÖ Conexi√≥n restablecida");
    }

    // ============================================================================
    // THEN STEPS - HTTP & BASIC VALIDATION
    // ============================================================================

    @Entonces("el c√≥digo de respuesta HTTP debe ser {int}")
    public void codigoRespuestaHttp(int expectedStatusCode) {
        assertThat(lastResponse.statusCode())
                .as("HTTP Status Code")
                .isEqualTo(expectedStatusCode);

        logger.info("‚úÖ HTTP Status: {}", expectedStatusCode);
    }

    @Y("el campo {string} debe ser {string}")
    public void campoDebeSerValor(String field, String expectedValue) {
        String actualValue = lastResponse.jsonPath().getString(field);

        assertThat(actualValue)
                .as("Campo %s debe ser %s", field, expectedValue)
                .isEqualTo(expectedValue);

        logger.info("‚úÖ Campo '{}': {}", field, actualValue);
        Allure.addAttachment(field, actualValue);
    }

    @Y("el campo {string} debe contener {string}")
    public void campoDebeContener(String field, String expectedSubstring) {
        String actualValue = lastResponse.jsonPath().getString(field);

        assertThat(actualValue)
                .as("Campo %s debe contener %s", field, expectedSubstring)
                .contains(expectedSubstring);

        logger.info("‚úÖ Campo '{}' contiene: {}", field, expectedSubstring);
    }

    @Y("el tiempo de respuesta debe ser menor a {int} milisegundos")
    public void tiempoRespuestaMenorQue(int maxResponseTime) {
        long responseTime = lastResponse.time();

        assertThat(responseTime)
                .as("Tiempo de respuesta")
                .isLessThan((long) maxResponseTime);

        logger.info("‚úÖ Tiempo de respuesta: {}ms (l√≠mite: {}ms)",
                responseTime, maxResponseTime);
        Allure.addAttachment("Response Time Validation",
                responseTime + "ms < " + maxResponseTime + "ms");
    }

    // ============================================================================
    // THEN STEPS - ISO8583 VALIDATION
    // ============================================================================

    @Y("el mensaje ISO8583 debe tener MTI {string}")
    @Step("Validar MTI del mensaje: {expectedMTI}")
    public void mensajeISODebeTenerMTI(String expectedMTI) {
        String actualMTI = lastResponse.jsonPath().getString("mti");

        assertThat(actualMTI)
                .as("MTI del mensaje ISO8583")
                .isEqualTo(expectedMTI);

        logger.info("‚úÖ MTI: {}", actualMTI);
        Allure.addAttachment("MTI", actualMTI);
    }

    @Y("el campo {int} del mensaje ISO debe ser {string}")
    public void campoISODebeSer(int fieldNumber, String expectedValue) {
        // üîç DEBUG: Ver la respuesta completa
        logger.info("üîç Response JSON completo: {}", lastResponse.asString());
        logger.info("üîç Status Code: {}", lastResponse.statusCode());

        Map<String, String> fields = lastResponse.jsonPath()
                .getMap("fields", String.class, String.class);

        // Validaci√≥n segura con null-check
        assertThat(fields)
                .as("El mensaje debe contener campos ISO8583")
                .isNotNull()
                .isNotEmpty();

        String actualValue = fields.get(String.valueOf(fieldNumber));

        assertThat(actualValue)
                .as("Campo %d del mensaje ISO", fieldNumber)
                .isEqualTo(expectedValue);

        logger.info("‚úÖ Campo ISO {}: {}", fieldNumber, actualValue);
    }

    @Entonces("el mensaje ISO8583 debe cumplir con:")
    public void mensajeISODebeCumplir(DataTable dataTable) {
        logger.info("üîç Validando estructura del mensaje ISO8583...");

        Map<String, String> fields = lastResponse.jsonPath()
                .getMap("fields", String.class, String.class);

        // Validaci√≥n segura con null-check
        assertThat(fields)
                .as("El mensaje debe contener campos ISO8583")
                .isNotNull()
                .isNotEmpty();

        List<Map<String, String>> rows = dataTable.asMaps();

        for (Map<String, String> row : rows) {
            String campo = row.get("Campo");
            String valorEsperado = row.get("Valor Esperado");
            String tipoValidacion = row.get("Tipo");

            String valorActual;
            if (campo.equals("MTI")) {
                valorActual = lastResponse.jsonPath().getString("mti");
            } else {
                valorActual = fields.get(campo);
            }

            ValidationHelper.validateField(campo, valorActual, valorEsperado, tipoValidacion);

            logger.info("‚úÖ Campo {}: {} ({})", campo, valorActual, tipoValidacion);
        }

        logger.info("‚úÖ Validaci√≥n de estructura ISO8583 completada");
    }

    @Y("la respuesta debe tener MTI {string}")
    public void respuestaDebeTenerMTI(String expectedMTI) {
        mensajeISODebeTenerMTI(expectedMTI);
    }

    @Y("el campo {int} de la respuesta debe existir")
    public void campoRespuestaDebeExistir(int fieldNumber) {
        Map<String, String> fields = lastResponse.jsonPath()
                .getMap("fields", String.class, String.class);

        // Validaci√≥n segura con null-check
        assertThat(fields)
                .as("El mensaje debe contener campos ISO8583")
                .isNotNull()
                .isNotEmpty();

        logger.info("‚úÖ Campo {} existe en respuesta", fieldNumber);
    }

    // ============================================================================
    // THEN STEPS - ERROR VALIDATION
    // ============================================================================

    @Y("el c√≥digo de respuesta debe ser uno de: {}")
    public void codigoRespuestaDebeSerUnoDE(List<String> validCodes) {
        String responseCode = lastResponse.jsonPath().getString("responseCode");

        assertThat(validCodes)
                .as("C√≥digo de respuesta v√°lido")
                .contains(responseCode);

        logger.info("‚úÖ C√≥digo de respuesta: {} (uno de: {})",
                responseCode, validCodes);
    }

    @Y("el mensaje de respuesta debe indicar rechazo")
    public void mensajeIndicaRechazo() {
        boolean isSuccessful = lastResponse.jsonPath().getBoolean("successful");

        assertThat(isSuccessful)
                .as("Transacci√≥n debe ser rechazada")
                .isFalse();

        String responseMessage = lastResponse.jsonPath().getString("responseMessage");
        logger.info("‚úÖ Mensaje de rechazo: {}", responseMessage);
    }

    @Y("debo recibir errores de validaci√≥n")
    public void recibirErroresValidacion() {
        List<String> errors = lastResponse.jsonPath().getList("validationErrors");

        assertThat(errors)
                .as("Debe haber errores de validaci√≥n")
                .isNotEmpty();

        logger.info("‚úÖ Errores de validaci√≥n recibidos: {}", errors);
        Allure.addAttachment("Validation Errors", errors.toString());
    }

    @Y("los errores deben incluir {string}")
    public void erroresDebenIncluir(String expectedError) {
        List<String> errors = lastResponse.jsonPath().getList("validationErrors");

        boolean containsError = errors.stream()
                .anyMatch(error -> error.contains(expectedError));

        assertThat(containsError)
                .as("Errores deben incluir: %s", expectedError)
                .isTrue();

        logger.info("‚úÖ Error '{}' encontrado en validaci√≥n", expectedError);
    }

    @Entonces("deber√≠a recibir un error de timeout")
    public void recibirErrorTimeout() {
        boolean isSuccessful = lastResponse.jsonPath().getBoolean("successful");

        assertThat(isSuccessful)
                .as("Transacci√≥n debe fallar por timeout")
                .isFalse();

        String errorType = lastResponse.jsonPath().getString("errorType");
        logger.info("‚úÖ Error de timeout detectado: {}", errorType);
    }

    // ============================================================================
    // THEN STEPS - SPECIAL VALIDATIONS
    // ============================================================================

    @Y("debo recibir informaci√≥n de saldo")
    public void recibirInformacionSaldo() {
        // En ISO8583, el saldo puede venir en campo 54 (additional amounts)
        // Verificamos que la respuesta sea exitosa como proxy
        boolean isSuccessful = lastResponse.jsonPath().getBoolean("successful");

        assertThat(isSuccessful)
                .as("Debe recibir informaci√≥n de saldo exitosamente")
                .isTrue();

        logger.info("‚úÖ Informaci√≥n de saldo recibida");
    }

    @Y("el STAN debe ser √∫nico y secuencial")
    @Step("Validar STAN √∫nico y secuencial")
    public void stanUnicoSecuencial() {
        String stan = lastResponse.jsonPath().getString("stan");

        assertThat(stan)
                .as("STAN debe existir")
                .isNotNull()
                .matches("\\d{6}");

        logger.info("‚úÖ STAN √∫nico: {}", stan);
        Allure.addAttachment("STAN", stan);
    }

    @Entonces("todas las transacciones deben completarse exitosamente")
    public void todasTransaccionesExitosas() {
        for (int i = 0; i < multipleResponses.size(); i++) {
            Response response = multipleResponses.get(i);
            boolean isSuccessful = response.jsonPath().getBoolean("successful");

            assertThat(isSuccessful)
                    .as("Transacci√≥n %d debe ser exitosa", i+1)
                    .isTrue();
        }

        logger.info("‚úÖ Todas las {} transacciones completadas exitosamente",
                multipleResponses.size());
    }

    @Y("cada transacci√≥n debe tener un STAN √∫nico")
    public void cadaTransaccionSTANUnico() {
        Set<String> stans = multipleResponses.stream()
                .map(response -> response.jsonPath().getString("stan"))
                .collect(Collectors.toSet());

        assertThat(stans)
                .as("Todos los STANs deben ser √∫nicos")
                .hasSize(multipleResponses.size());

        logger.info("‚úÖ {} STANs √∫nicos verificados", stans.size());
    }

    @Y("el tiempo promedio de respuesta debe ser menor a {int} milisegundos")
    public void tiempoPromedioMenorQue(int maxAvgTime) {
        double avgTime = multipleResponses.stream()
                .mapToLong(Response::time)
                .average()
                .orElse(0);

        assertThat(avgTime)
                .as("Tiempo promedio de respuesta")
                .isLessThan((double) maxAvgTime);

        logger.info("‚úÖ Tiempo promedio: {}ms (l√≠mite: {}ms)",
                avgTime, maxAvgTime);
        Allure.addAttachment("Avg Response Time", avgTime + "ms");
    }


    // ============================================================================
    // UTILITY METHODS
    // ============================================================================

    private String maskPan(String pan) {
        if (pan == null || pan.length() < 10) {
            return "INVALID_PAN";
        }
        return pan.substring(0, 6) + "******" + pan.substring(pan.length()-4);
    }

    private String maskTrack2(String track2) {
        if (track2 == null || track2.length() < 10) {
            return "INVALID_TRACK2";
        }
        return track2.substring(0, 6) + "***MASKED***";
    }
    private void logRequestParameters() {
        logger.info("üì§ ============ REQUEST PARAMETERS ============");
        logger.info("   Type: BALANCE_INQUIRY");
        logger.info("   PAN: {}", maskPan(currentPan));
        logger.info("   Track2: {}", maskTrack2(currentTrack2));
        logger.info("   Terminal: {}", currentTerminalId);
        logger.info("   Card Acceptor: {}", currentCardAcceptorId);
        logger.info("   Account: {}", currentAccount);
        logger.info("üì§ =============================================");
    }
}