package com.iso8583.test.utils;

import com.iso8583.test.client.ISO8583ApiClient;
import com.iso8583.test.models.TransactionRequest;
import com.iso8583.test.models.TransactionResponse;
import com.iso8583.test.services.TransactionService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Contexto compartido entre Steps de Cucumber
 *
 * Prop√≥sito:
 * - Compartir estado entre diferentes steps de un scenario
 * - Almacenar request/response actual
 * - Almacenar servicios inicializados (ApiClient, TransactionService)
 * - Proporcionar almacenamiento temporal para datos del scenario
 *
 * Patr√≥n: Singleton por Scenario (gracias a PicoContainer de Cucumber)
 * Cada scenario de Cucumber tiene su propia instancia de TestContext
 */
public class TestContext {

    private static final Logger logger = LoggerFactory.getLogger(TestContext.class);

    // ============================================================================
    // SERVICIOS Y CLIENTES
    // ============================================================================

    private ISO8583ApiClient apiClient;
    private TransactionService transactionService;

    // ============================================================================
    // ESTADO DE TRANSACCI√ìN ACTUAL
    // ============================================================================

    /**
     * Request actual que se est√° construyendo o se envi√≥
     */
    private TransactionRequest currentRequest;

    /**
     * Response actual recibida del simulador
     */
    private TransactionResponse currentResponse;

    /**
     * Builder para construir el request paso a paso
     * Los steps de "Given" van agregando campos al builder
     */
    private TransactionRequest.TransactionRequestBuilder requestBuilder;

    // ============================================================================
    // ESTADO PARA ESCENARIOS DE M√öLTIPLES TRANSACCIONES
    // ============================================================================

    /**
     * Lista de responses para scenarios que env√≠an m√∫ltiples transacciones
     * Ejemplo: "Cuando env√≠o 5 solicitudes consecutivas"
     */
    private List<TransactionResponse> multipleResponses;

    /**
     * Timestamp de inicio de la transacci√≥n (para medir tiempos)
     */
    private long transactionStartTime;

    // ============================================================================
    // ALMACENAMIENTO TEMPORAL GEN√âRICO
    // ============================================================================

    /**
     * Map gen√©rico para almacenar cualquier dato temporal del scenario
     * √ötil para casos especiales sin necesidad de agregar campos espec√≠ficos
     */
    private Map<String, Object> scenarioData;

    // ============================================================================
    // CONSTRUCTOR
    // ============================================================================

    public TestContext() {
        logger.debug("üèóÔ∏è Nuevo TestContext creado para scenario");
        this.multipleResponses = new ArrayList<>();
        this.scenarioData = new HashMap<>();
    }

    // ============================================================================
    // INICIALIZACI√ìN DE SERVICIOS
    // ============================================================================

    /**
     * Inicializa el ApiClient y TransactionService con la URL base
     */
    public void initializeServices(String baseUrl) {
        logger.info("üîß Inicializando servicios con baseUrl: {}", baseUrl);

        this.apiClient = new ISO8583ApiClient(baseUrl);
        this.transactionService = new TransactionService(apiClient);

        logger.debug("‚úÖ Servicios inicializados");
    }

    /**
     * Verifica si los servicios est√°n inicializados
     */
    public boolean areServicesInitialized() {
        return apiClient != null && transactionService != null;
    }

    // ============================================================================
    // GESTI√ìN DEL REQUEST BUILDER
    // ============================================================================

    /**
     * Inicia un nuevo builder para construir el request
     */
    public TransactionRequest.TransactionRequestBuilder startNewRequest() {
        logger.debug("üÜï Iniciando nuevo request builder");
        this.requestBuilder = TransactionRequest.builder();
        return this.requestBuilder;
    }

    /**
     * Obtiene el builder actual (lo crea si no existe)
     */
    public TransactionRequest.TransactionRequestBuilder getRequestBuilder() {
        if (requestBuilder == null) {
            logger.debug("‚ö†Ô∏è Builder no exist√≠a, creando nuevo");
            startNewRequest();
        }
        return requestBuilder;
    }

    /**
     * Construye y guarda el request final desde el builder
     */
    public TransactionRequest buildAndSetRequest() {
        if (requestBuilder == null) {
            throw new IllegalStateException("No hay builder activo. Usa startNewRequest() primero");
        }

        this.currentRequest = requestBuilder.build();
        logger.debug("‚úÖ Request construido y guardado: {}", currentRequest.getTransactionType());

        return this.currentRequest;
    }

    // ============================================================================
    // GETTERS Y SETTERS - REQUEST/RESPONSE
    // ============================================================================

    public TransactionRequest getCurrentRequest() {
        return currentRequest;
    }

    public void setCurrentRequest(TransactionRequest currentRequest) {
        this.currentRequest = currentRequest;
        logger.debug("üìù Request actual actualizado: {}",
                currentRequest != null ? currentRequest.getTransactionType() : "null");
    }

    public TransactionResponse getCurrentResponse() {
        return currentResponse;
    }

    public void setCurrentResponse(TransactionResponse currentResponse) {
        this.currentResponse = currentResponse;
        logger.debug("üìù Response actual actualizada - C√≥digo: {}",
                currentResponse != null ? currentResponse.getResponseCode() : "null");
    }

    // ============================================================================
    // GETTERS - SERVICIOS
    // ============================================================================

    public ISO8583ApiClient getApiClient() {
        if (apiClient == null) {
            throw new IllegalStateException(
                    "ApiClient no inicializado. Ejecuta initializeServices(baseUrl) primero"
            );
        }
        return apiClient;
    }

    public TransactionService getTransactionService() {
        if (transactionService == null) {
            throw new IllegalStateException(
                    "TransactionService no inicializado. Ejecuta initializeServices(baseUrl) primero"
            );
        }
        return transactionService;
    }

    // ============================================================================
    // M√öLTIPLES TRANSACCIONES
    // ============================================================================

    /**
     * Agrega una response a la lista de m√∫ltiples transacciones
     */
    public void addResponse(TransactionResponse response) {
        multipleResponses.add(response);
        logger.debug("‚ûï Response agregada a lista m√∫ltiple (total: {})", multipleResponses.size());
    }

    /**
     * Obtiene todas las responses de transacciones m√∫ltiples
     */
    public List<TransactionResponse> getMultipleResponses() {
        return new ArrayList<>(multipleResponses); // Retornar copia para evitar modificaciones
    }

    /**
     * Limpia la lista de m√∫ltiples responses
     */
    public void clearMultipleResponses() {
        logger.debug("üßπ Limpiando lista de m√∫ltiples responses");
        multipleResponses.clear();
    }

    /**
     * Obtiene el n√∫mero de transacciones m√∫ltiples almacenadas
     */
    public int getMultipleResponsesCount() {
        return multipleResponses.size();
    }

    // ============================================================================
    // MEDICI√ìN DE TIEMPOS
    // ============================================================================

    /**
     * Marca el inicio de una transacci√≥n para medir tiempos
     */
    public void startTransactionTimer() {
        this.transactionStartTime = System.currentTimeMillis();
        logger.debug("‚è±Ô∏è Timer de transacci√≥n iniciado");
    }

    /**
     * Obtiene el tiempo transcurrido desde el inicio de la transacci√≥n
     */
    public long getElapsedTime() {
        if (transactionStartTime == 0) {
            logger.warn("‚ö†Ô∏è Timer no fue iniciado");
            return 0;
        }
        return System.currentTimeMillis() - transactionStartTime;
    }

    /**
     * Resetea el timer de transacci√≥n
     */
    public void resetTransactionTimer() {
        this.transactionStartTime = 0;
        logger.debug("üîÑ Timer reseteado");
    }

    // ============================================================================
    // ALMACENAMIENTO TEMPORAL GEN√âRICO
    // ============================================================================

    /**
     * Guarda un dato temporal en el contexto del scenario
     */
    public void setData(String key, Object value) {
        scenarioData.put(key, value);
        logger.debug("üíæ Dato guardado: {} = {}", key, value);
    }

    /**
     * Obtiene un dato temporal del contexto
     */
    public Object getData(String key) {
        return scenarioData.get(key);
    }

    /**
     * Obtiene un dato temporal con casting autom√°tico
     */
    @SuppressWarnings("unchecked")
    public <T> T getData(String key, Class<T> type) {
        Object value = scenarioData.get(key);
        if (value == null) {
            return null;
        }

        if (type.isInstance(value)) {
            return (T) value;
        }

        throw new ClassCastException(
                String.format("Dato '%s' no es del tipo esperado %s (es %s)",
                        key, type.getSimpleName(), value.getClass().getSimpleName())
        );
    }

    /**
     * Verifica si existe un dato temporal
     */
    public boolean hasData(String key) {
        return scenarioData.containsKey(key);
    }

    /**
     * Elimina un dato temporal
     */
    public void removeData(String key) {
        scenarioData.remove(key);
        logger.debug("üóëÔ∏è Dato eliminado: {}", key);
    }

    // ============================================================================
    // LIMPIEZA DE CONTEXTO
    // ============================================================================

    /**
     * Limpia todo el contexto para un nuevo scenario
     * Este m√©todo se llama t√≠picamente en los hooks de @Before
     */
    public void clear() {
        logger.debug("üßπ Limpiando TestContext completo");

        this.currentRequest = null;
        this.currentResponse = null;
        this.requestBuilder = null;
        this.multipleResponses.clear();
        this.scenarioData.clear();
        this.transactionStartTime = 0;

        // NO limpiamos apiClient ni transactionService - se reutilizan

        logger.debug("‚úÖ TestContext limpio");
    }

    /**
     * Limpia solo los datos de transacci√≥n (mantiene servicios)
     * √ötil entre steps dentro del mismo scenario
     */
    public void clearTransactionData() {
        logger.debug("üßπ Limpiando solo datos de transacci√≥n");

        this.currentRequest = null;
        this.currentResponse = null;
        this.requestBuilder = null;
        this.transactionStartTime = 0;

        logger.debug("‚úÖ Datos de transacci√≥n limpios");
    }

    // ============================================================================
    // M√âTODOS DE UTILIDAD
    // ============================================================================

    /**
     * Verifica si hay una transacci√≥n actual en progreso
     */
    public boolean hasCurrentTransaction() {
        return currentRequest != null || requestBuilder != null;
    }

    /**
     * Verifica si hay una response actual disponible
     */
    public boolean hasCurrentResponse() {
        return currentResponse != null;
    }

    /**
     * Obtiene un resumen del estado actual del contexto (para debugging)
     */
    public String getContextSummary() {
        return String.format(
                "TestContext[" +
                        "services=%s, " +
                        "currentRequest=%s, " +
                        "currentResponse=%s, " +
                        "multipleResponses=%d, " +
                        "scenarioData=%d items" +
                        "]",
                areServicesInitialized() ? "initialized" : "not initialized",
                currentRequest != null ? currentRequest.getTransactionType() : "null",
                currentResponse != null ? currentResponse.getResponseCode() : "null",
                multipleResponses.size(),
                scenarioData.size()
        );
    }

    @Override
    public String toString() {
        return getContextSummary();
    }
}